/*
  Falak compiler - WebAssembly text file (Wat) code generator.
  Copyright (C) 2013-2021 , ITESM CEM
  
  Luis Daniel Rivera Salinas  - A01374997
  Ricardo David Zambrano Figueroa - A1379700
  Gerardo Arturo Valderrama Quiroz - A01374994

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;

namespace Falak {

    class WatVisitor {
        public HashSet<string> GlobalVariableTable;
        public IDictionary<string, Type> GlobalFunctionTable;
        public IDictionary<string, HashSet<string>> SymbolTable;
        public int cycles, cantTabs;
        public int ret = 0;
        public string FunName;
        string block, passblock;
        public bool VarDefinitionBody, ArrayBody;

    //    void DeclareAPI()
    //     {
    //         GlobalFunctionTable["printi"] = new Type(true,1);
    //         GlobalFunctionTable["printc"] = new Type(true,1);
    //         GlobalFunctionTable["prints"] = new Type(true,1);
    //         GlobalFunctionTable["println"]  = new Type(true,0);
    //         GlobalFunctionTable["readi"]  = new Type(true,0);
    //         GlobalFunctionTable["reads"] = new Type(true,0);
    //         GlobalFunctionTable["new"] = new Type(true,1);
    //         GlobalFunctionTable["size"] = new Type(true,1);
    //         GlobalFunctionTable["add"] = new Type(true,2);
    //         GlobalFunctionTable["get"] = new Type(true,2);
    //         GlobalFunctionTable["set"] = new Type(true,3);

    //     }

        public string tabs(){
            string regresar = "\t";
            for(int i = 0; i < cantTabs; i++){
                regresar += "\t";
            }
            return regresar;
        }

        // Debug, if is empty or with error
        public string tabs(int sumar){
            string regresar = "\t";

            if(sumar == -99 || sumar == -98){
                regresar = "";
            }

            for(int i = 0; i < cantTabs; i++){
                regresar += "\t";
            }

            if(sumar == -98){
                cantTabs -= 1;
            }else if(sumar != -99){
                cantTabs += sumar;
            }

            return regresar;
        }

       //-----------------------------------------------------------
        public WatVisitor(IDictionary<string, HashSet<string>> SymbolTable, HashSet<string> GlobalVariableTable, IDictionary<string, Type> GlobalFunctionTable) {
            this.GlobalVariableTable = GlobalVariableTable;
            this.GlobalFunctionTable = GlobalFunctionTable;
            this.SymbolTable = SymbolTable;
            this.VarDefinitionBody = false;
            this.ArrayBody = false;
        }

        //-----------------------------------------------------------
        public string Visit(Program node) {

            return ";; WebAssembly text format code generated by "
                + "the falak compiler.\n\n"
                + "(module\n"
                + " (import \"falak\" \"printi\" (func $printi (param i32) (result i32)))\n"
                + " (import \"falak\" \"printc\" (func $printc (param i32) (result i32)))\n"
                + " (import \"falak\" \"prints\" (func $prints (param i32) (result i32)))\n"
                + " (import \"falak\" \"println\" (func $println (result i32)))\n"
                + " (import \"falak\" \"readi\" (func $readi (result i32)))\n"
                + " (import \"falak\" \"reads\" (func $reads (result i32)))\n"
                + " (import \"falak\" \"new\" (func $new (param i32) (result i32)))\n"
                + " (import \"falak\" \"size\" (func $size (param i32) (result i32)))\n"
                + " (import \"falak\" \"add\" (func $add (param i32) (param i32) (result i32)))\n"
                + " (import \"falak\" \"get\" (func $get (param i32) (param i32) (result i32)))\n"
                + " (import \"falak\" \"set\" (func $set (param i32) (param i32) (param i32) (result i32)))\n"
                + VisitChildren((dynamic) node) // FunList
                + ")\n";
            
        }

        //-----------------------------------------------------------       

        public string Visit(DefinitionList node) {
            return VisitChildren((dynamic) node);
        }


        //-----------------------------------------------------------
        public string Visit(VarDef node) {
            var variableName = node.AnchorToken.Lexeme;
            if(GlobalVariableTable.Contains(variableName)){
                return tabs() + $"(global ${variableName} (mut i32) (i32.const 0))\n";
            }else{
                if (!VarDefinitionBody){
                    return tabs() + $"(param ${node.AnchorToken.Lexeme} i32)\n";
                }else{
                    return tabs() + $"(local ${node.AnchorToken.Lexeme} i32)\n";
                } 
            }
                
        }

        //-----------------------------------------------------------
        public string Visit(VarList node) {
            return VisitChildren((dynamic) node); 
        }

        //-----------------------------------------------------------
        public string Visit(FunctionDefinition node) {
            FunName = node.AnchorToken.Lexeme;
            Console.WriteLine(FunName);
            ret = 1;
            string regresar = "";
            if(FunName == "main"){
                regresar = "\n" + tabs(1) + $"(func\n"
                + tabs() + "(export \"main\")\n"
                + VisitChildren((dynamic) node)
                + "i32.const 0\n"
                + tabs(-1)
                + "\n)";
            }else{
                regresar = "\n" + tabs(1) + $"(func ${node.AnchorToken.Lexeme}\n"
                + VisitChildren((dynamic) node)
                + "i32.const 0\n"
                + tabs(-1)
                + "\n)";
            }
            return regresar;
            //string red = tabs() + "(result i32)\n";
            //string regresar2 = tabs() + "(local $_temp i32)\n"
            //+ VisitChildren((dynamic) node, 1);

            //    return regresar + red + regresar2 + tabs() + "i32.const 0\n"
			//    + tabs(-1) + "return\n" + tabs() + ")\n";
            //}
            //return regresar + red + regresar2  + tabs() + "i32.const 0\n"
            //    + tabs(-1) + "return\n" + tabs() + ")\n";
        }

        //-----------------------------------------------------------
        public string Visit(VariableDefinitionList node) {
            VarDefinitionBody = true;
            var regreso = tabs() + "(local $_temp i32)\n" + VisitChildren((dynamic) node);    
            VarDefinitionBody = false;
            return regreso;
        }

        //-----------------------------------------------------------
        public string Visit(ParameterList node) {
            return VisitChildren((dynamic) node) + tabs() + "(result i32)\n"; 
        }
        public string Params(ParameterList node){
          string regresa = "\n";
          foreach(var nodeC in node){
            regresa += tabs() + $"(param ${nodeC.AnchorToken.Lexeme} i32)\n";
          }
          return regresa;
        }

        //-----------------------------------------------------------
        public string Visit(StatementList node) {
            //Console.WriteLine("Llegue " + node.AnchorToken);
            return VisitChildren((dynamic) node);
        }

        //-----------------------------------------------------------
        public string Visit(StatementAssign node) {
            if(node[0].childs() > 1 && node[0].GetType() == new ExpressionList().GetType()){
                string arr = "";
                foreach(var n in node[0]){
                    arr += tabs() + "local.get $_temp\n"
                    + Visit((dynamic) n)
                    + tabs() + "call $add\n"
                    + tabs() + "drop\n";
                }
                return tabs() + "i32.const 0\n"
                + tabs() + "call $new\n"
                + tabs() + "local.set $_temp\n"
                + tabs() + "local.get $_temp\n"
                + arr
                + tabs() + $"{getVariableCategory(node)}.set ${node.AnchorToken.Lexeme}\n";
            }
            return Visit((dynamic) node[0])
                + tabs() + $"{getVariableCategory(node)}.set ${node.AnchorToken.Lexeme}\n";
        }

         //-----------------------------------------------------------
        public string Visit(StatementIncrease node) {
            return VisitChildren((dynamic) node)
                + tabs() +"i32.const 1\n"
                + tabs() +"i32.add\n"
                + tabs() +$"{getVariableCategory(node[0])}.set ${node[0].AnchorToken.Lexeme}\n";
        }

        //-----------------------------------------------------------
       public string Visit(StatementDecrease node) {
            return VisitChildren((dynamic) node)
                + tabs() +"i32.const 1\n"
                + tabs() + "i32.sub\n"
                + tabs() +  $"{getVariableCategory(node[0])}.set ${node[0].AnchorToken.Lexeme}\n";
        }

        //-----------------------------------------------------------
        public string Visit(StatementIf node) {
            return Visit((dynamic) node[0])
                + tabs(1) + "if\n"
                + VisitChildren((dynamic) node,1)
                + tabs(-98) + "end\n";
        }

        //-----------------------------------------------------------
        public string Visit(ElseIfList node) {
            if (node.childs() == 0){
                return "";
            }else{
                return  tabs(-99) + "else\n"
                + Visit((dynamic) node[0])
                + tabs(1) + "if\n"
                + VisitChildren((dynamic) node,1)
                + tabs(-98) + "end\n";
            }
            
        }

        //-----------------------------------------------------------
        public string Visit(Else node) { 
            if (node.childs() == 0){
                return "";
            }else{
                return  tabs(-99) + "else\n"
                + Visit((dynamic) node[0]);
            }
        }

        //-----------------------------------------------------------
        public string Visit(StatementWhile node) {
            passblock = block;
            cycles += 1;
            block = formatNested();
            cycles += 1;
            var loop = formatNested();
            string ret = tabs(1) + $"block ${block}\n"
                + tabs(1) + $"loop ${loop}\n\n"
                + Visit((dynamic) node[0]) + "\n"
                + tabs() + "i32.eqz\n"
                + tabs() + $"br_if ${block}\n\n"
                + Visit((dynamic) node[1]) + "\n"
                + tabs(-1) +$"br ${loop}\n"
                + tabs(-1) +"end\n"
                + tabs() +"end\n";
            block = passblock;
            return ret;
        }

        //-----------------------------------------------------------
        public string Visit(StatementDoWhile node) {
            passblock = block;
            cycles += 1;
            block = formatNested();
            cycles += 1;
            var loop = formatNested();
            string ret = tabs(1) + $"block ${block}\n"
                + tabs(1) + $"loop ${loop}\n"
                + Visit((dynamic) node[0]) + "\n"
                + Visit((dynamic) node[1][0]) + "\n"
                + tabs() + "i32.eqz\n"
                + tabs() + $"br_if ${block}\n\n"
                + tabs(-1) + $"br ${loop}\n"
                + tabs(-1) + "end\n"
                + tabs() + "end\n";
            block = passblock;
            return ret;
        }

        //-----------------------------------------------------------
        public string Visit(StatementBreak node) {
            return tabs() + $"br ${block}\n";
        }

        //-----------------------------------------------------------
        public string Visit(StatementReturn node) {
            ret = 0;
            if(node[0].childs() > 1 && node[0].GetType() == new ExpressionList().GetType()){
                string arr = "";
                foreach(var n in node[0]){
                    arr += tabs() + "local.get $_temp\n"
                    + Visit((dynamic) n)
                    + tabs() + "call $add\n"
                    + tabs() + "drop\n";
                }
            return tabs() + "i32.const 0\n"
            + tabs() + "call $new\n"
            + tabs() + "local.set $_temp\n"
            + tabs() + "local.get $_temp\n"
            + arr
            + tabs() + "return\n";
            }
            return Visit((dynamic) node[0])
            + tabs() + "return\n";
        }

        //-----------------------------------------------------------
        public string Visit(Empty node) {
            return "";
        }

        //-----------------------------------------------------------
        public string Visit(ExpressionList node) {
            if(ArrayBody == true){
                var regresar = "";
                if (node.childs() > 0){
                    for(int i = 0; i <= node.childs(); i++){
                        regresar += tabs() + "local.get $_temp\n";
                    }
                    foreach (var n in node){
                        regresar += Visit((dynamic) n)
                            + tabs() + "call $add\n"
                            + tabs() + "drop\n";
                    }
                }
                return regresar;
            }else {
                return VisitChildren((dynamic) node);
            }
            
        }

         //-----------------------------------------------------------
        public string Visit(Or node) {
            return Visit((dynamic) node[0])
                + tabs(1) + "if(result i32)\n"
                + tabs(-1) + "i32.const 1\n"
                + tabs(1) + "else\n"
                + Visit((dynamic) node[1])
                + tabs() + "i32.eqz\n"
                + tabs(-1) + "i32.eqz\n"
                + tabs() + "end\n";
        }

         //-----------------------------------------------------------
        public string Visit(Xor node) {
            return Visit((dynamic) node[0])
            + tabs() + "i32.eqz\n"
            + tabs() + "i32.eqz\n"
            + Visit((dynamic) node[1])
            + tabs() + "i32.eqz\n"
            + tabs() + "i32.eqz\n"
            + tabs() + "i32.xor\n"
            ;
        }

         //-----------------------------------------------------------
        public string Visit(And node) {
            return Visit((dynamic) node[0])
                + tabs(1) + "if(result i32)\n"
                + Visit((dynamic) node[1])
                + tabs() + "i32.eqz\n"
                + tabs(-1) + "i32.eqz\n"
                + tabs(1) + "else\n"
                + tabs(-1) + "i32.const 0\n"
                + tabs() + "end\n";
        }

        //-----------------------------------------------------------
        public string Visit(EqualTo node) {
            return Visit((dynamic) node[0])
                + Visit((dynamic) node[1])
                + tabs() + "i32.eq\n";
        }

        //-----------------------------------------------------------
        public string Visit(NotEqualTo node) {
            return Visit((dynamic) node[0])
                + Visit((dynamic) node[1])
                //+ tabs() + "i32.eq\n"
                + tabs() + "i32.eqz\n";
        }

        //-----------------------------------------------------------
        public string Visit(LessThan node) {
            return Visit((dynamic) node[0])
                + Visit((dynamic) node[1])
                + tabs() + "i32.lt_s\n";
        }

        //-----------------------------------------------------------
        public string Visit(LessEqual node) {
            return Visit((dynamic) node[0])
                + Visit((dynamic) node[1])
                + tabs() + "i32.le_s\n";
        }

        //-----------------------------------------------------------
        public string Visit(MoreThan node) {
            return Visit((dynamic) node[1])
                + Visit((dynamic) node[0])
                + tabs() + "i32.lt_s\n";
        }

        //-----------------------------------------------------------
        public string Visit(MoreEqual node) {
            return Visit((dynamic) node[1])
                + Visit((dynamic) node[0])
                + tabs() + "i32.le_s\n";
        }

        //-----------------------------------------------------------
        public string Visit(Plus node) {
           return Visit((dynamic) node[0])
                + Visit((dynamic) node[1])
                + tabs() + "i32.add\n";
        }

        //-----------------------------------------------------------
        public string Visit(Subs node) {
            return Visit((dynamic) node[0])
                + Visit((dynamic) node[1])
                + tabs() + "i32.sub\n";
        }

        //-----------------------------------------------------------
        public string Visit(Mul node) {
            return Visit((dynamic) node[1])
                + Visit((dynamic) node[0])
                + tabs() + "i32.mul\n";
        }

        //-----------------------------------------------------------
        public string Visit(Div node) {
            return Visit((dynamic) node[0])
                + Visit((dynamic) node[1])
                + tabs() + "i32.div_s\n";
        }

        //-----------------------------------------------------------
        public string Visit(Mod node) {
            return Visit((dynamic) node[0])
                + Visit((dynamic) node[1])
                + tabs() + "i32.rem_s\n";
        }

         //-----------------------------------------------------------
        public string Visit(Positive node) {
            return Visit((dynamic) node[0]);
        }

         //-----------------------------------------------------------
        public string Visit(Neg node) {
            return tabs() + "i32.const 0\n"
                + Visit((dynamic) node[0])
                + tabs() + "i32.sub\n";
        }

         //-----------------------------------------------------------
        public string Visit(Not node) {
            return Visit((dynamic) node[0])
                // Decirle a gerry
                //+ tabs() + "i32.const 0\n"
                + tabs() + "i32.eqz\n";
        }

        //-----------------------------------------------------------
        public string Visit(FunCall node) {
            if(node.childs() > 0){
                return Visit((dynamic) node[0])
                + tabs() +$"call ${node.AnchorToken.Lexeme}\n"
                + tabs() + "drop\n";
            }
            else{
                return tabs() + $"call ${node.AnchorToken.Lexeme}\n"
                + tabs() + "drop\n";
            }
        }

        //-----------------------------------------------------------
        public string Visit(VarRef node) {
            return tabs() + $"{getVariableCategory(node)}.get ${node.AnchorToken.Lexeme}\n";
        }


        //-----------------------------------------------------------
        public string Visit(True node) {
            return tabs() + "i32.const 1\n";
        }

        //-----------------------------------------------------------
        public string Visit(False node) {
            return tabs() + "i32.const 0\n";
        }

        //-----------------------------------------------------------
        public string Visit(Lit_Integer node) {
            return tabs() + $"i32.const {node.AnchorToken.Lexeme}\n";
        }

        //-----------------------------------------------------------
        public string Visit(Lit_Character node) {
            char[] str = node.AnchorToken.Lexeme.ToCharArray();
            int i = 1;
            int c = 0;
            if(str[i] == '\\'){
                i++;
                if(str[i] == 'n'){
                c = 10;
                }
                else if(str[i] == '"'){
                c = 34;
                }
                else if(str[i] == 'r'){
                c = 13;
                }
                else if(str[i] == 't'){
                c = 9;
                }
                else if(str[i] == '\\'){
                c = 92;
                }
                else if(str[i] == '\''){
                c = 39;
                }
                else if(str[i] == 'u'){
                string w = "";
                w += str[i+1];
                w += str[i+2];
                w += str[i+3];
                w += str[i+4];
                w += str[i+5];
                w += str[i+6];
                c = int.Parse(w, System.Globalization.NumberStyles.HexNumber);
                i += 6;
                }
            }else{
                c = Convert.ToInt32(str[1]);
            }
            return tabs() + $"i32.const {c}\n";
        }

         //-----------------------------------------------------------
        public string Visit(Lit_String node) {
            string regresar = tabs() + "i32.const 0\n"
            + tabs() + "call $new\n"
            + tabs() + "local.set $_temp\n";
            char[] str = node.AnchorToken.Lexeme.ToCharArray();
            for(int i = 1; i < str.Length-1; i++){
                regresar += tabs() + "local.get $_temp\n";
            }
            for(int i = 1; i < str.Length - 1; i++){
                
                if(str[i] == '\\'){
                i++;
                int c = 0;
                if(str[i] == 'n'){
                    c = 10;
                }
                else if(str[i] == '"'){
                    c = 34;
                }
                else if(str[i] == 'r'){
                    c = 13;
                }
                else if(str[i] == 't'){
                    c = 9;
                }
                else if(str[i] == '\\'){
                    c = 92;
                }
                else if(str[i] == '\''){
                    c = 39;
                }
                else if(str[i] == 'u'){
                    string w = "";
                    w += str[i+1];
                    w += str[i+2];
                    w += str[i+3];
                    w += str[i+4];
                    w += str[i+5];
                    w += str[i+6];
                    c = int.Parse(w, System.Globalization.NumberStyles.HexNumber);
                    i += 6;
                }
                regresar += tabs() + "i32.const " + c + "\n";
                }else{
                regresar += tabs() + "i32.const " + Convert.ToInt32(str[i]) + "\n";
                }
                regresar += tabs() + "call $add\n";
                regresar += tabs() + "drop\n";
            }
            return regresar;
        }


         //-----------------------------------------------------------
        public string Visit(LitArray node) {
            string regresar = tabs() + "i32.const 0\n"
            + tabs() + "call $new\n"
            + tabs() + "local.set $_temp\n";
            //+ tabs() + "local.get $_temp\n";

            ArrayBody = true;
            string regresar2 = VisitChildren((dynamic) node);
            ArrayBody = false;

            return regresar + regresar2;
        }
        


        //-----------------------------------------------------------
        string VisitChildren(Node node) {
            var sb = new StringBuilder();
            foreach (var n in node) {
                sb.Append(Visit((dynamic) n));
            }
            return sb.ToString();
        }

        string VisitChildren(Node node, int cambio) {
            int i = 0;
            var sb = new StringBuilder();
            foreach (var n in node) {
                if(i >= cambio){
                    sb.Append(Visit((dynamic) n));
                }
                i++;
            }
            return sb.ToString();
        }

        public string getVariableCategory(Node node){
          foreach(var n in SymbolTable[FunName]){
              if(n == node.AnchorToken.Lexeme){
                return "local";
              }
          }
          return "global";
        }

        public string formatNested(){
            if (cycles < 10){
                return "0000" +cycles.ToString();
            }else if(cycles <100){
                return "000" +cycles.ToString();
            }else if(cycles <1000){
                return "00" +cycles.ToString();
            }else if(cycles <10000){
                return "0" +cycles.ToString();
            }else{
                return cycles.ToString();
            }
        }
        
    }
}
